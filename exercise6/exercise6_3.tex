\documentclass[12pt]{scrartcl}%{article} % Beginn der LaTeX-Datei

%% twocolumn

\usepackage{amsmath,amssymb}  % erleichtert Mathe 
\usepackage{enumerate}% schicke Nummerierung

\usepackage{graphicx} % für Grafik-Einbindung
%\usepackage{hyperref}

\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[boxed]{algorithm2e}
\usepackage{parskip}
 % Einstellungen, wenn man deutsch schreiben will, z.B. Trennregeln
\usepackage[utf8]{inputenc}  % für Unix-Systeme
  % ermöglicht die direkte Eingabe von Umlauten und ß
  % evt. obige Zeile ersetzen durch
  % \usepackage[ansinew]{inputenc}  % für Windows
  % \usepackage[applemac]{inputenc} % für den Mac
\usepackage{listings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  ntheorem
%
\usepackage[thmmarks,amsmath,hyperref,noconfig]{ntheorem} 
  % erlaubt es, Sätze, Definitionen etc. einfach durchzunummerieren.
\newtheorem{satz}{Satz}[section] % Nummerierung nach Abschnitten
\newtheorem{hilfssatz}[satz]{Hilfssatz}
\newtheorem{kor}[satz]{Korollar}

\theorembodyfont{\upshape}
\newtheorem{beispiel}[satz]{Beispiel}
\newtheorem{bemerkung}[satz]{Bemerkung}
\newtheorem{definition}[satz]{Definition} %[section]

\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theorembodyfont{\normalfont}
\theoremseparator{.}
\theoremsymbol{\ensuremath{_\blacksquare}}
\newtheorem{beweis}{Beweis}
\qedsymbol{\ensuremath{_\blacksquare}}
%\theoremclass{LaTeX}
%
% Ende ntheorem
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\pagestyle{empty}
%
% Ändern der bedruckten Fläche der Seite
% \addtolength{\textwidth}{3cm}  % Befehl mit zwei Argumenten
% \addtolength{\textheight}{3cm}
% \hoffset-2cm % verschiebt das Textfenster nach links
% \voffset-5mm % verschiebt das Textfenster nach oben
%
\parindent=0pt %% keine Einzug zu Beginn von Abs\"atzen
%\parskip=2mm   %% erzeugt einen zusätzliche Zeilenabstand zwischen
                %% Absätzen. Nötig bei \parindent=0pt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ermöglicht, farbigen Text zu drucken.
\usepackage{color}
% Und nun werden die Farben definiert - daran können Sie nach Belieben selber rumspielen.
\definecolor{white}{rgb}{1,1,1}
\definecolor{darkred}{rgb}{0.3,0,0}
\definecolor{darkgreen}{rgb}{0,0.3,0}
\definecolor{darkblue}{rgb}{0,0,0.3}
\definecolor{pink}{rgb}{0.78,0.09,0.51}
\definecolor{purple}{rgb}{0.28,0.24,0.55}
\definecolor{orange}{rgb}{1,0.6,0.0}
\definecolor{grey}{rgb}{0.4,0.4,0.4}
\definecolor{aquamarine}{rgb}{0.4,0.8,0.65}


\DeclareMathOperator{\GL}{GL} % einige Macro, siehe am Ende Abschn. 2
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\cP}{{\mathcal P}}
\newcommand{\bO}[1]{\mathcal O(#1)}
\newcommand{\bT}[1]{\Theta (#1)}
\newcommand{\bOg}[1]{\Omega (#1)}

% Code-Macro, wenn man mal etwas als Code highlighten möchte
\newcommand{\code}[1]{\lstinline[basicstyle=\ttfamily\color{black}]{#1}}

\begin{document}

\author{Dennis Hempfing, Sebastian Koall}
\title{Übung 6}
\date{} 
\pagestyle{myheadings}
\markright{\hfill Dennis Hempfing, Sebastian Koall}

\maketitle % erzeugt den Kopf

\section*{Aufgabe 3}
\subsubsection*{a)}
Gesucht ist $\bOg{\log{(n)}}$ für den Algorithmus. Der Adversary kann auf jede Frage der Form $x < a[i]$ oder $x > a[i]$ mit dem jeweils größeren der beiden Teile antworten. Um möglichst wenige Fragen stellen zu müssen, ist die Frage mit zwei möglichen gleichlangen Ergebnissen am sinnvollsten. Der Adversary kann in diesem Fall bei jeder Teilung einen der beiden Teilbereiche zurückgeben. Somit muss der verbleibende Array solange halbiert werden, bis nur noch 1 Element im betrachteten Array ist. Das übriggebliebene Element muss dann das Ergebnis x sein. Die Anzahl der nötigen Schritte ist somit genau $ \log {(n)}$.

\subsubsection*{b)}
Anfragen der Form $x < a[i]$ oder $x > a[i]$ resultieren in jeweils zwei Teilarrays, welche in Frage kommen. Unsere Eingabemenge ist n. Nach dem informationstheoretischen Argument müssen $\log_2{(n)}$ Fragen gestellt werden. Daraus resultiert auch die Argumentation mit dem informationstheoretischen Argument in einer Laufzeit von $\bOg{\log{(n)}}$.

\subsubsection*{c)}
Für ein beliebiges aber festes k werden k + 1 Teilarrays untersucht. Dementsprechend ist die Größe der betrachteten Teilarrays nach $log_{k+1}{(n)}$ auf 1 gesunken. Auf die Frage in welchem Teil sich x befindet kann der Adversary maximal nur $log_{k+1}{(n)}$ antworten und somit die Rückgabe des richtigen Ergebnisses verzögern. Daraus ergibt sich eine untere Schranke $\bOg{\log_{k + 1}{(n)}}$.  

\subsubsection*{d)}
Bei der Argumentation mit dem informationstheoretischen Argument ergibt sich die Zahl der möglichen Antworten aufgrund der Eingabe. Die Anzahl beträgt genau k + 1. Aus k  + 1 und der Größe der Eingabemenge n ergibt sich somit eine Mindestanzahl von $\log_{k + 1}{(n)}$ Schritten. Die untere Schranke ist somit $\bOg{\log_{k + 1}{(n)}}$.

\end{document}
